package iso8583

import (
	"encoding/hex"
	"fmt"
	"testing"
)

func TestISOParseByte(t *testing.T) {
	// MTI = 0200
	// Field (3) = 000010
	// Field (4) = 1500
	// Field (7) = 1206041200
	// Field (11) = 000001
	// Field (41) = 12340001
	// Field (49) = 840
	isobyte := []byte{
		0x60, 0x00, 0x32, 0x00, 0x00, 0x02, 0x00, 0x30, 0x20, 0x07, 0x80, 0x20, 0xC0, 0x12, 0x64, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x00, 0x00, 0x92, 0x00, 0x51, 0x00, 0x00, 0x00,
		0x32, 0x00, 0x37, 0x53, 0x36, 0x19, 0x00, 0x02, 0x41, 0x87, 0x65, 0xD2, 0x50, 0x32, 0x01, 0x94,
		0x71, 0x82, 0x12, 0x00, 0x00, 0x00, 0x37, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x36, 0x30, 0x30,
		0x30, 0x30, 0x30, 0x38, 0x37, 0x37, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x36, 0x5B, 0x6B, 0x19,
		0xED, 0x5B, 0xE9, 0x40, 0x95, 0x01, 0x47, 0x5F, 0x2A, 0x02, 0x03, 0x60, 0x82, 0x02, 0x18, 0x00,
		0x84, 0x07, 0xA0, 0x00, 0x00, 0x00, 0x04, 0x10, 0x10, 0x95, 0x05, 0x80, 0x00, 0x04, 0x08, 0x00,
		0x9A, 0x03, 0x21, 0x03, 0x02, 0x9C, 0x01, 0x00, 0x9F, 0x02, 0x06, 0x00, 0x00, 0x00, 0x10, 0x02,
		0x00, 0x9F, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9F, 0x09, 0x02, 0x00, 0x02, 0x9F,
		0x10, 0x12, 0x01, 0x10, 0xA0, 0x00, 0x01, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0xFF, 0x9F, 0x1A, 0x02, 0x03, 0x60, 0x9F, 0x1E, 0x08, 0x35, 0x31, 0x34, 0x36,
		0x33, 0x33, 0x39, 0x35, 0x9F, 0x26, 0x08, 0xA3, 0xE1, 0x6C, 0x4A, 0xB9, 0x3C, 0xFC, 0xB1, 0x9F,
		0x27, 0x01, 0x80, 0x9F, 0x33, 0x03, 0xE0, 0xF8, 0xC8, 0x9F, 0x34, 0x03, 0x42, 0x03, 0x00, 0x9F,
		0x35, 0x01, 0x22, 0x9F, 0x36, 0x02, 0x00, 0x19, 0x9F, 0x37, 0x04, 0x8F, 0x1D, 0xD4, 0x95, 0x9F,
		0x41, 0x04, 0x00, 0x00, 0x00, 0x92, 0x9F, 0x53, 0x01, 0x52, 0x00, 0x11, 0xDF, 0x01, 0x08, 0x35,
		0x31, 0x34, 0x36, 0x33, 0x33, 0x39, 0x35, 0x01, 0x60, 0xB4, 0x03, 0xDC, 0x3A, 0xD3, 0x37, 0x6E,
		0xC9, 0x6D, 0x00, 0x43, 0xB6, 0x15, 0x58, 0xE4, 0x8F, 0x99, 0x9B, 0x4C, 0x79, 0x12, 0x8C, 0xDD,
		0xB6, 0x74, 0x5E, 0x0B, 0xE7, 0xFA, 0x8C, 0x72, 0x03, 0xD4, 0xA1, 0x88, 0xA1, 0xAB, 0xF5, 0xA6,
		0xD8, 0x09, 0x67, 0x1F, 0xA0, 0x2D, 0xAA, 0xE9, 0xC5, 0x19, 0x0B, 0x25, 0x35, 0xD8, 0xC2, 0x30,
		0x44, 0x89, 0x6F, 0x8C, 0xEF, 0xD3, 0xF3, 0x31, 0x75, 0xD9, 0xA8, 0x34, 0x58, 0x1E, 0x98, 0x3A,
		0x73, 0x3F, 0xA2, 0x1B, 0x5C, 0x4F, 0x6C, 0x34, 0xC5, 0x90, 0x0C, 0x8B, 0x79, 0x2E, 0xF2, 0xCA,
		0x9F, 0x8D, 0x14, 0xDB, 0x11, 0x31, 0x6D, 0x75, 0x20, 0xF0, 0xE1, 0x15, 0x71, 0xA0, 0xA4, 0xB7,
		0x60, 0x91, 0xB0, 0x0D, 0xDA, 0xA4, 0x45, 0x0A, 0x30, 0x65, 0xC2, 0x9C, 0x31, 0x51, 0xBB, 0x4F,
		0xC2, 0xEC, 0x41, 0xEF, 0x5E, 0xE6, 0xD4, 0xFF, 0xC1, 0x09, 0x3E, 0x80, 0x69, 0x77, 0x0C, 0x9A,
		0x8A, 0xDE, 0x65, 0x9C, 0x37, 0xC1, 0xD8, 0x76, 0xF2, 0x07, 0xA7, 0x43, 0x38, 0x71, 0xE1, 0x79,
		0xD0, 0x4F, 0xA5, 0x4F, 0xC7, 0xC8, 0x97, 0x14, 0x59, 0x00, 0x06, 0x34, 0x30, 0x30, 0x30, 0x30,
		0x31}

	isomsg := string(isobyte)
	isostruct := NewISOStruct("spec1987pos.yml", true)
	parsed, err := isostruct.Parse(isomsg, true)
	if err != nil {
		fmt.Println(err)
		t.Errorf("parse iso message failed")
	}

	isomsgUnpacked, err := parsed.ToString()
	if err != nil {
		fmt.Println(err)
		t.Errorf("failed to unpack valid isomsg")
	}
	fmt.Println(isomsgUnpacked)
	// if isomsgUnpacked != isomsg {
	// 	t.Errorf("%s should be %s", isomsgUnpacked, isomsg)
	// }
	fmt.Printf("%#v, %#v\n%#v", parsed.Mti, parsed.Bitmap, parsed.Elements)
}

func TestISOParseInt(t *testing.T) {

	isobyte := []byte{
		96,0,50,0,0,4,0,112,36,7,128,0,192,2,100,22,83,4,135,32,0,0,8,72,0,0,0,0,0,0,2,1,0,0,1,32,35,6,0,81,0,1,0,50,0,55,55,
		48,48,48,48,48,54,48,48,48,48,48,56,55,55,48,48,48,48,48,48,54,1,87,95,42,2,3,96,130,2,116,0,132,7,160,0,0,6,2,16,16,
		149,5,8,0,4,136,0,154,3,33,3,22,156,1,0,159,2,6,0,0,0,2,1,0,159,3,6,0,0,0,0,0,0,159,9,2,1,0,159,16,28,159,1,160,0,128,
		0,0,145,243,17,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,159,26,2,3,96,159,30,8,53,49,52,54,51,51,57,53,159,38,8,235,72,167,
		52,131,92,159,216,159,39,1,128,159,51,3,224,248,200,159,52,3,2,0,0,159,53,1,34,159,54,2,3,179,159,55,4,253,168,58,116,
		159,65,4,0,0,1,32,159,83,1,82,0,17,223,1,8,53,49,52,54,51,51,57,53,1,96,180,3,220,58,211,55,110,201,198,159,188,92,177,
		104,150,181,7,86,112,228,200,27,244,118,252,59,125,47,215,14,125,202,49,36,240,155,38,232,2,88,128,49,253,147,102,189,55,
		148,50,71,79,223,3,37,119,62,178,98,90,163,211,181,42,32,79,139,96,10,66,115,42,231,190,76,66,68,225,96,127,29,4,224,83,151,
		57,40,246,53,27,27,124,91,221,13,110,13,3,46,55,127,198,230,71,215,105,129,198,121,216,234,55,187,227,241,187,188,246,112,8,
		203,40,214,90,94,229,75,185,143,93,73,69,151,158,122,57,169,227,38,88,231,185,171,231,2,239,112,114,67,130,59,176,202,13,249,
		81,30,22,38,236,68,0,6,52,48,48,48,48,56}

	isomsg := string(isobyte)
	isostruct := NewISOStruct("spec1987pos.yml", true)
	parsed, err := isostruct.Parse(isomsg, true)
	if err != nil {
		fmt.Println(err)
		t.Errorf("parse iso message failed")
	}

	isomsgUnpacked, err := parsed.ToString()
	if err != nil {
		fmt.Println(err)
		t.Errorf("failed to unpack valid isomsg")
	}
	fmt.Println(isomsgUnpacked)
	// if isomsgUnpacked != isomsg {
	// 	t.Errorf("%s should be %s", isomsgUnpacked, isomsg)
	// }
	fmt.Printf("%#v, %#v\n%#v", parsed.Mti, parsed.Bitmap, parsed.Elements)
}

func TestISOParse(t *testing.T) {
	// MTI = 0200
	// Field (3) = 000010
	// Field (4) = 1500
	// Field (7) = 1206041200
	// Field (11) = 000001
	// Field (41) = 12340001
	// Field (49) = 840
	isomsg := "02003220000000808000000010000000001500120604120000000112340001840"
	isostruct := NewISOStruct("spec1987.yml", true)
	parsed, err := isostruct.Parse(isomsg, false)
	if err != nil {
		fmt.Println(err)
		t.Errorf("parse iso message failed")
	}

	isomsgUnpacked, err := parsed.ToString()
	if err != nil {
		fmt.Println(err)
		t.Errorf("failed to unpack valid isomsg")
	}
	if isomsgUnpacked != isomsg {
		t.Errorf("%s should be %s", isomsgUnpacked, isomsg)
	}
	// fmt.Printf("%#v, %#v\n%#v", parsed.Mti, parsed.Bitmap, parsed.Elements)
}

func TestEmpty(t *testing.T) {
	one := NewISOStruct("spec1987.yml", false)

	if one.Mti.String() != "" {
		t.Errorf("Empty generates invalid MTI")
	}
	one.AddMTI("0200")
	one.AddField(3, "000010")
	one.AddField(4, "000000001500")
	one.AddField(7, "1206041200")
	one.AddField(11, "000001")
	one.AddField(41, "12340001")
	one.AddField(49, "840")

	expected := "02003220000000808000000010000000001500120604120000000112340001840"
	unpacked, _ := one.ToString()
	if unpacked != expected {
		t.Errorf("Manually constructed isostruct produced %s not %s", unpacked, expected)
	}
}

func TestEmptyPos(t *testing.T) {
	one := NewISOStruct("spec1987pos.yml", false)

	if one.Mti.String() != "" {
		t.Errorf("Empty generates invalid MTI")
	}
	one.AddMTI("0200")
	one.Tpdu = []byte{96, 0, 50, 0, 0}
	one.AddField(3, "000010")
	one.AddField(4, "000000001500")
	one.AddField(7, "1206041200")
	one.AddField(11, "000001")
	one.AddField(41, "12340001")
	one.AddField(49, "840")

	dataByte, _ := hex.DecodeString("0200322000000080800000001000000000150031323036303431323030000001")
	expected := "12340001840"
	expected = string(dataByte) + expected

	unpacked, _ := one.ToString()
	if unpacked != expected {
		t.Errorf("Manually constructed isostruct produced %x not %x", []byte(unpacked), []byte(expected))
	}
}
